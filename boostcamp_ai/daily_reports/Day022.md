# Day 22. PageRank, Cascade | 신기정 마스터

> PageRank: 합리적이고 신뢰성 높은 스코어링 방법

웹과 그래프

- 웹은 웹페이지와 하이퍼링크로 구성된 거대한 Directed Graph
  - 각 웹페이지: 정점
  - 각 웹페이지 내 존재하는 하이퍼링크: 간선
- 이러한 거대한 그래프로부터 효율적인 검색 => 검색 엔진의 등장

검색 엔진의 첫번쨰 시도: 유사한 웹페이지끼리 모아 거대한 디렉토리로 정리한 검색 엔진

- 문제점: 
  - 무한함: 웹페이지 수가 증가함에 따라 카테고리 수와 깊이가 모두 기하급수적으로 커졌기 때문에 감당하기 어려워짐
  - 모호함: 카테고리 경계가 모호한 경우 정리가 모호함

검색 엔진의 두번째 시도: 웹페이지 내 키워드에 의존한 검색 엔진

- 사용자가 입력한 검색 키워드를 바탕으로, 해당 키워드를 여러번 포함한 웹페이지를 검색 결과로 반환
- 문제점:
  - 악용 가능성: '축구'에 대한 키워드로 성인 사이트가 반환되도록 조작이 가능하는 등

PageRank: 합리적 레이팅 방식을 통해 위 시도들의 문제점을 모두 해결

- 핵심 아이디어: ***투표***

  - 투표를 통해 사용자 키워드와 (1)관련성이 높고 (2)신뢰할 수 있는 웹페이지를 찾아 반환
  - 투표의 주체는 웹페이지: 웹페이지 u(정점)의 작성자가 웹페이지 v를 하이퍼링크(이웃)로 걸었다면, u 작성자는 v를 믿는 것, 즉 *<u>'투표'</u>*한 것
  - 이러한 논리로 여러 작성자가 하이퍼링크를 걸었을 수록, 즉 들어오는 간선이 많을 수록 신뢰할 수 있는 웹사이트가 되는 셈
  - 허나, 간선의 수가 많은 것만으로는 신뢰성 부족: 인위적으로 웹페이지를 여러 개 만들어서 간선 수를 부풀릴 수 있음
  - 이를 해결 하기 위해 <u>*가중 투표*</u>를 진행
  - 투표 개념을 활용한 재귀 연산을 통해 각 웹사이트(정점)별 점수 산출

- 정의

  ![](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+r_%7Bj%7D+%3D+%5Csum_%7Bi+%5Cin+N_%7Bin%7D%28j%29%7D+%5Cfrac+%7Br_%7Bi%7D%7D+%7Bd_%7Bout%7D%28i%29%7D)

  - ![pagerank_1](https://github.com/iloveslowfood/iloveTIL/blob/main/boostcamp_ai/etc/images/week05/pagerank_1.jpg?raw=true)
  - Initialization: 각 정점의 레이팅 점수의 초기값은 1 / (전체 정점 수)
  - 특정 정점 N_j의 레이팅 구하기
    - N_j로 들어오는 이웃을 파악
    - 각 이웃에 대하여, (1 / 각 이웃의 나가는 간선 수)를 해당 이웃의 레이팅 점수를 곱하고, 모두 더하면 이것이 N_j의 레이팅
  - 모든 정점에 대한 레이팅을 구하여 레이팅 벡터를 만들어 나가며, 수렴할 때까지 반복

임의 보행(Random) 관점에서의 PageRank

- 웹서핑하는 사용자가 임의 보행을 반복하고 나면 확률 분포 p(t)는 수렴이 보장. 즉, p(t) = p(t+1) = p0
  
- 이때, 확률 분포 p를 정상 분포(stationary distribution)라고 부름
  
- 페이지랭크 부여 방식을 임의 보행에 견주어 이해할 수 있으며, 이는 사용자들이 자연스럽게 웹서핑을 하는 과정에서, 검색어에 대해 중요한 웹페이지가 합리적이고 신뢰성 있게 선별될 수 있음을 의미

- ![pagerank_2](https://github.com/iloveslowfood/iloveTIL/blob/main/boostcamp_ai/etc/images/week05/pagerank_2.jpg?raw=true)

- 위 그림과 같이 수렴되는 형태이고, 이는 다음 그림과 같이 PageRank 부여하는 수식과 같은 형태

  ![pagerank_3](https://github.com/iloveslowfood/iloveTIL/blob/main/boostcamp_ai/etc/images/week05/pagerank_3.jpg?raw=true)

순간이동(teleport)

- 위 PageRank 방법은 ***수렴을 보장하지 않는다.*** 진동 발산 등 특정한 레이팅에 도달하지 않을 가능성이 존재

  - 막다른 정점과 스파이더 트랩이 포함된 경우 이러한 문제 발생
  - 막다른 정점: 해당 정점으로 들어가는 간선은 존재하나, 나가는 간선이 없어 고립되는 정점
  - 스파이더 트랩: 두 정점에 대하여 서로를 향하는 간선이 존재해, 값의 수렴이 어려워지게 됨

- 위의 문제를 해결하기 위해 순간이동 방법을 활용. 임의 보행 관점에서, 웹서퍼의 행동을 다음과 같이 정의 <- 수정의 여지가 있음!

  1. 현재 웹페이지에 하이퍼링크가 없는 경우 임의 웹페이지로 순간이동
  2. 현재 웹페이지에 하이퍼링크가 있는 경우, 앞면이 나올 확률이 a이 동전을 던짐
     - 앞면일 경우, 하이퍼링크 중 하나를 균일 확률로 선택
     - 뒷면일 경우, 임의의 웹페이지로 순간이동

  - 이러한 과정은 다음과 같은 수식으로 표현. 앞면이 나올 확률이 α인 동전을 던지는 것

    ![pagerank_4](https://github.com/iloveslowfood/iloveTIL/blob/main/boostcamp_ai/etc/images/week05/pagerank_4.jpg?raw=true)

    - summation항은 하이퍼링크를 선택하는 경우를, 뒷쪽의 항은 순간이동하는 경우를 의미

> 그래프를 활용한 기계학습

전파의 종류

- 그래프를 통한 정보의 전파: 트위터를 통해 시민들이 정부의 부정부패에 맞서 연대하는 경우
- 그래프를 통한 고장의 전파: 일부 장비의 고장이 다른 장비의 과부하로 이어지는 경우
- 그래프를 통한 질병의 전파: 사회의 거대 소셜 네트워크를 통해 코로나19 등 질병이 전파되는 경우

의사결정 기반의 전파: 카카오톡을 쓸까, 라인을 쓸까? 넷플릭스를 쓸까, 왓챠를 쓸까?

- 주변 사람들의 의사결정이 본인의 의사결정에 영향을 미치는 경우에 대한 전파 모형

- 선형 임계치 모형: 가장 간단한 의사결정 기반 전파 모형

- 특정 정점과 연결된 간선 중 일정 비율, 즉 임계치(threshold) 이상 동일한 의사결정을 했다면, 해당 점점 또한 이와 같은 의사결정을 하게 되는 것

- 다음의 경우와 같이 다른 의사결정을 한 소수의 정점이 반복적으로 다른 정점에 의사결정을 전파(임계치: 0.55)

  ![cascade_1](https://github.com/iloveslowfood/iloveTIL/blob/main/boostcamp_ai/etc/images/week05/cascade_1.jpg?raw=true)

  - 맨 좌측의 파란 두 정점은 붉은 색 의사결정 비율이 임계치를 넘지 않았으므로 의사결정이 전파되지 않음

- 여기서 중요한 것은, 최초 전파 정점, 즉 ***시드 집합을 어떻게 설정하느냐에 따라 전파 결과가 달라진다는 것***

  ![cascade_2](https://github.com/iloveslowfood/iloveTIL/blob/main/boostcamp_ai/etc/images/week05/cascade_2.jpg?raw=true)

전파 최대화 문제(influence maximalization): 시드 집합을 잘 고르자!

- 쌩 일반인보다 인스타 인플루언서들에게 상품 홍보를 하는 이유: 전파 범위가 하늘과 땅차이니까!

- |V|개의 정점이 있을 경우, 시드 집합 크기를 k로 제한하더라도 경우의수는 ![](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%7B%7Cv%7C%7D+%5Cchoose+%7Bk%7D)가 되어 현실적으로 연산할 수 없는 크기를 벗어날 수 있음

  - NP-hard임이 증명되었음(다항 연산으로는 해결 불가)

- 전파 최대화 해결 방법

  - 휴리스틱: 경험적 접근. 실험적으로 좋은 성능을 가져올 수 있으나, 보장하지는 않는 방법

    - 페이지랭크가 높은 정점들 중 일부를 선택
    - 연결 중심성이 높은 정점들 중 일부를 선택
    - 매개 중심성이 높은 정점들 중 일부를 선택

  - 탐욕 알고리즘: 가장 전파를 잘 할만한 최초 전파자를 순차적으로 선발

    1. {1, 2, ..., |V|}의 정점 집합에서 시뮬레이션을 반복하여 평균값을 구한 뒤, 전파의 크기가 가장 큰 집합 {x} 선발

    2. {x, 1}, {x, 2}, ... , {x, |V|}를 비교해, 전파를 최대화하는 시드 집합을 선발

    3. 목표하는 크기의 시드 집합이 될 때까지 반복

    - 시드 집합의 원소 간 상호작용은 고려하지 않음

    - 독립 전파 모형일 경우, 이론적으로 정확도 보장

      ![](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%28Average%5C%2C%5C%2Cof%5C%2C%5C%2CInfluece%5C%2C%5C%2CSize%29+%5Cge+%281+-+%5Cfrac+%7B1%7D+%7Be%7D%29+%5Capprox+0.632)



> Attitude & Tips

- 기본적으로 '그래프'는 정점 간 오고 가는 간선을 각각 1개로 정의